<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        body {
            background-color: #2c3e50;
            color: #ecf0f1;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            /* Add these for better background image handling */
            background-size: cover;
            background-position: center;
            background-attachment: fixed; /* Optional, but nice */
            transition: background-image 0.5s ease-in-out; /* Smooth transition */
        }

        h1 {
            font-size: 3rem;
            letter-spacing: 5px;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 0 20px;
            position: absolute;
            top: 10px;
        }

        #auth-container button, #user-display button {
            background-color: transparent;
            color: #ecf0f1;
            border: 2px solid #7f8c8d;
            padding: 5px 15px;
            font-size: 0.9rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.3s, color 0.3s;
            border-radius: 4px;
        }

        #auth-container button:hover, #user-display button:hover {
            background-color: #ecf0f1;
            color: #2c3e50;
        }

        #logoutButton {
            border-color: #e74c3c;
        }
        #logoutButton:hover {
            background-color: #e74c3c;
        }

        #profilePic {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
            margin-right: 10px;
            object-fit: cover; /* Prevents image distortion */
        }

        #score-container {
            display: flex;
            justify-content: space-around;
            width: 600px;
            margin-bottom: 1rem;
        }

        #score, #highScore {
            font-size: 1.2rem;
            flex-basis: 50%;
            text-align: center;
            padding: 5px;
        }

        canvas {
            border: 4px solid #ecf0f1;
            box-shadow: 0 0 20px #ecf0f1;
        }

        #retryButton {
            background-color: #e74c3c;
            color: #ecf0f1;
            border: 2px solid #ecf0f1;
            padding: 10px 20px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin-top: 1rem;
            transition: background-color 0.3s, transform 0.3s;
        }

        #retryButton:hover {
            background-color: #c0392b;
            transform: scale(1.05);
        }

        #settingsButton {
            background-color: #3498db;
            color: #ecf0f1;
            border: 2px solid #ecf0f1;
            padding: 10px 20px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin-top: 1rem;
            transition: background-color 0.3s, transform 0.3s;
        }

        #settingsButton:hover {
            background-color: #2980b9;
            transform: scale(1.05);
        }

        .modal h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .setting-option {
            margin-bottom: 20px;
        }

        #speed-controls button {
            background-color: #555;
            color: #ecf0f1;
            border: 2px solid #777;
            padding: 8px 16px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin: 0 5px;
            transition: background-color 0.3s;
        }

        #speed-controls button:hover {
            background-color: #777;
        }

        #speed-controls button.active {
            background-color: #27ae60; /* Green to indicate active */
            border-color: #2ecc71;
        }

        #graphics-controls button {
            background-color: #555;
            color: #ecf0f1;
            border: 2px solid #777;
            padding: 8px 16px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin: 0 5px;
            transition: background-color 0.3s;
        }

        #graphics-controls button:hover {
            background-color: #777;
        }

        #graphics-controls button.active {
            background-color: #3498db;
            /* Blue to indicate active */
            border-color: #3498db;
        }

        #background-controls button {
            background-color: #555;
            color: #ecf0f1;
            border: 2px solid #777;
            padding: 8px 16px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin: 0 5px;
            transition: background-color 0.3s;
        }

        #background-controls button:hover {
            background-color: #777;
        }

        #background-controls button.active {
            background-color: #e67e22;
            /* Orange */
            border-color: #d35400;
        }

        #applyCustomBgBtn {
            margin-left: 10px;
            padding: 10px;
            background-color: #e67e22;
            color: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #applyCustomBgBtn:hover {
            background-color: #d35400;
        }


        .hidden {
            display: none;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #34495e;
            padding: 20px 40px;
            border: 4px solid #ecf0f1;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            z-index: 1000;
            text-align: center;
        }

        .modal input {
            display: block;
            width: 90%;
            padding: 10px;
            margin: 10px auto;
            font-family: 'Courier New', Courier, monospace;
            background-color: #1c2833;
            color: #ecf0f1;
            border: 2px solid #7f8c8d;
            border-radius: 4px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .modal input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px #3498db;
        }

        /* General styles for all modal buttons */
        .modal button {
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            border-radius: 4px;
        }

        /* Specific styles for button types */
        .modal .btn-primary {
            background-color: #27ae60; /* Green for submit/action */
            color: #ecf0f1;
        }
        .modal .btn-primary:hover {
            background-color: #2ecc71;
        }

        .modal .btn-secondary {
            background-color: #7f8c8d; /* Grey for close/cancel */
            color: #ecf0f1;
        }
        .modal .btn-secondary:hover {
            background-color: #95a5a6;
        }

        .modal .btn-danger {
            background-color: #e74c3c; /* Red for destructive action */
            color: #ecf0f1;
        }

        .modal .btn-danger:hover {
            background-color: #c0392b;
        }

        #saveProfilePicBtn {
            margin-left: 10px;
            padding: 10px;
            background-color: #8e44ad;
            /* Amethyst */
            color: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #saveProfilePicBtn:hover {
            background-color: #9b59b6;
        }

        .modal form > div {
            margin-top: 20px;
        }

        .input-with-button {
            display: flex;
            align-items: center;
            width: 90%;
            margin: 10px auto;
        }

        .input-with-button input {
            flex-grow: 1;
            margin: 0; /* Override default margin */
            width: auto; /* Override default width */
        }

        #generateUsernameBtn {
            margin-left: 10px;
            padding: 10px;
            background-color: #3498db;
            color: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        #generateUsernameBtn:hover { background-color: #2980b9; }

        #signupForm .checkbox-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 5px auto 15px;
            width: 90%;
        }

        #signupForm .checkbox-container label {
            margin-left: 10px;
            font-size: 0.9rem;
        }

        #profileModal p {
            text-align: left;
            font-size: 1.1rem;
            margin: 15px 0;
        }

        #profileModal p strong {
            color: #bdc3c7;
        }

        #profileModalButton {
            background-color: #8e44ad; /* Amethyst */
            color: #ecf0f1;
            border: 2px solid #9b59b6;
            padding: 8px 16px;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            margin: 0 5px;
            transition: background-color 0.3s;
            border-radius: 4px;
        }

        #profileModalButton:hover {
            background-color: #9b59b6;
        }

        #settingsModal > .btn-secondary {
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div id="auth-container">
            <button id="loginButton">Login</button>
            <button id="signupButton">Signup</button>
        </div>
        <div id="user-display" class="hidden">
            <img id="profilePic" src="" alt="PFP" class="hidden">
            <span id="welcomeMessage"></span>
            <button id="logoutButton">Logout</button>
        </div>
    </div>

    <h1>SNAKE</h1>
    <div id="score-container">
        <div id="score">Score: 0</div>
        <div id="highScore">High Score: 0</div>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <p style="margin-top: 1rem;">Use Arrow Keys or WASD to Move</p>
    <div>
        <button id="retryButton" class="hidden">Retry</button>
        <button id="settingsButton">Settings</button>
    </div>

    <div id="settingsModal" class="modal hidden">
        <h2>Settings</h2>
        <div id="profile-setting-container" class="setting-option hidden">
            <h3>Account</h3>
            <button id="profileModalButton">View Profile</button>
        </div>
        <div class="setting-option">
            <h3>Game Speed</h3>
            <div id="speed-controls">
                <button class="speed-option" data-speed="180">Slow</button>
                <button class="speed-option" data-speed="120">Normal</button>
                <button class="speed-option" data-speed="70">Fast</button>
            </div>
        </div>
        <div class="setting-option">
            <h3>Graphics Style</h3>
            <div id="graphics-controls">
                <button class="graphics-option" data-style="modern">Modern</button>
                <button class="graphics-option" data-style="classic">Classic</button>
                <button class="graphics-option" data-style="cyber">Cyber</button>
            </div>
        </div>
        <div class="setting-option">
            <h3>Background</h3>
            <div id="background-controls">
                <button class="background-option" data-style="black">Black</button>
                <button class="background-option" data-style="blue">Blue</button>
                <button class="background-option" data-style="stars">Stars</button>
            </div>
            <div class="input-with-button" style="margin-top: 10px;">
                <input type="text" id="customBgUrl" placeholder="Image URL for background">
                <button type="button" id="applyCustomBgBtn">Apply</button>
            </div>
        </div>
        <button id="closeSettings" class="btn-secondary">Close</button>
    </div>

    <!-- Login and Signup Modals -->
    <div id="loginModal" class="modal hidden">
        <h2>Login</h2>
        <form id="loginForm">
            <input type="text" id="loginIdentifier" placeholder="Username, Email, or Mobile" required>
            <input type="password" id="loginPassword" placeholder="Password" required>
            <div>
                <button type="submit" class="btn-primary">Login</button>
                <button type="button" class="close-modal btn-secondary">Close</button>
            </div>
        </form>
    </div>

    <div id="signupModal" class="modal hidden">
        <h2>Signup</h2>
        <form id="signupForm">
            <div class="input-with-button">
                <input type="text" id="signupUsername" placeholder="Username" required>
                <button type="button" id="generateUsernameBtn">Generate</button>
            </div>
            <input type="email" id="signupEmail" placeholder="Email">
            <div class="checkbox-container">
                <input type="checkbox" id="noEmailCheckbox">
                <label for="noEmailCheckbox">Bypass email</label>
            </div>
            <input type="tel" id="signupMobile" placeholder="Mobile Number" required>
            <input type="password" id="signupPassword" placeholder="Password" required>
            <div>
                <button type="submit" class="btn-primary">Signup</button>
                <button type="button" class="close-modal btn-secondary">Close</button>
            </div>
        </form>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="modal hidden">
        <h2>User Profile</h2>
        <p><strong>Username:</strong> <span id="profileUsername"></span></p>
        <p><strong>Email:</strong> <span id="profileEmail"></span></p>
        <p><strong>Mobile:</strong> <span id="profileMobile"></span></p>
        <div class="input-with-button" style="margin-top: 20px;">
            <input type="text" id="profilePicUrl" placeholder="Profile Picture URL">
            <button type="button" id="saveProfilePicBtn">Save</button>
        </div>
        <div class="modal-actions">
            <button type="button" id="deleteAccountButton" class="btn-danger">Delete Account</button>
            <button type="button" class="close-modal btn-secondary">Close</button>
        </div>
    </div>

    <!-- Account Selection Modal -->
    <div id="accountSelectionModal" class="modal hidden">
        <h2>Select Account</h2>
        <p>This mobile number is linked to multiple accounts. Please select one to continue.</p>
        <div id="accountList"></div>
        <button type="button" class="close-modal btn-secondary" style="margin-top: 20px;">Cancel</button>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const retryButton = document.getElementById('retryButton');
        const highScoreDisplay = document.getElementById('highScore');
        const settingsButton = document.getElementById('settingsButton');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsButton = document.getElementById('closeSettings');
        const speedControlButtons = document.querySelectorAll('.speed-option');
        const graphicsControlButtons = document.querySelectorAll('.graphics-option');
        const backgroundControlButtons = document.querySelectorAll('.background-option');
        // Auth elements
        const authContainer = document.getElementById('auth-container');
        const userDisplay = document.getElementById('user-display');
        const loginButton = document.getElementById('loginButton');
        const signupButton = document.getElementById('signupButton');
        const profilePic = document.getElementById('profilePic');
        const logoutButton = document.getElementById('logoutButton');
        const welcomeMessage = document.getElementById('welcomeMessage');
        const loginModal = document.getElementById('loginModal');
        const signupModal = document.getElementById('signupModal');
        const profileModal = document.getElementById('profileModal');
        const accountSelectionModal = document.getElementById('accountSelectionModal');
        const accountList = document.getElementById('accountList');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const signupUsernameInput = document.getElementById('signupUsername');
        const signupEmailInput = document.getElementById('signupEmail');
        const noEmailCheckbox = document.getElementById('noEmailCheckbox');
        const profileUsername = document.getElementById('profileUsername');
        const profileEmail = document.getElementById('profileEmail');
        const profileMobile = document.getElementById('profileMobile');
        const closeModalButtons = document.querySelectorAll('.close-modal');
        const profileSettingContainer = document.getElementById('profile-setting-container');
        const profileModalButton = document.getElementById('profileModalButton');
        const deleteAccountButton = document.getElementById('deleteAccountButton');
        const profilePicUrlInput = document.getElementById('profilePicUrl');
        const saveProfilePicBtn = document.getElementById('saveProfilePicBtn');
        const customBgUrlInput = document.getElementById('customBgUrl');
        const applyCustomBgBtn = document.getElementById('applyCustomBgBtn');

        const generateUsernameBtn = document.getElementById('generateUsernameBtn');
        // Game constants
        const GRID_SIZE = 20;
        const TILE_COUNT = canvas.width / GRID_SIZE; // 400 / 20 = 20

        // Game state
        let backgroundStyle = 'black';
        const STAR_COUNT = 200; // Increased for larger canvas
        let stars = [];
        let graphicsStyle = 'modern'; // Default style
        let gameSpeed = 120; // Default speed, will be updated from settings
        let snake = [{ x: 15, y: 15 }]; // Snake starts in the middle of 600x600 grid
        let food = { x: 20, y: 20 };
        let dx = 0; // Direction x
        let dy = 0; // Direction y
        let score = 0;
        let highScore = 0;
        let gameOver = false;
        let changingDirection = false; // Prevents rapid 180-degree turns

        // --- GAME LOGIC ---

        /**
         * The main function that runs the game loop.
         */
        function main() {
            if (gameOver) {
                displayGameOver();
                return;
            }

            changingDirection = false;
            setTimeout(function onTick() {
                clearCanvas();
                drawFood();
                moveSnake();
                drawSnake();
                // Call main again to create the loop
                main();
            }, gameSpeed);
        }

        /**
         * Clears the canvas for the next frame.
         */
        function clearCanvas() {
            // When using a body background, we just clear the canvas
            if (backgroundStyle === 'custom') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            } else if (backgroundStyle === 'blue') {
                ctx.fillStyle = '#1a1a2e'; // A dark navy blue
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else { // black or stars background is black
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw stars if applicable
            if (backgroundStyle === 'stars') {
                ctx.fillStyle = 'white';
                stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            // Then draw the grid on top
            drawGrid();
        }

        /**
         * Draws a subtle grid on the canvas.
         */
        function drawGrid() {
            ctx.strokeStyle = (graphicsStyle === 'cyber') ? '#4b0082' : '#34495e'; // Cyber: Indigo, Else: Dark blue/grey
            ctx.lineWidth = (graphicsStyle === 'cyber') ? 0.7 : 0.5;
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        /**
         * Draws the snake on the canvas.
         */
        function drawSnake() {
            if (graphicsStyle === 'classic') {
                ctx.fillStyle = '#2ecc71'; // Classic green
                snake.forEach(part => {
                    ctx.fillRect(part.x * GRID_SIZE, part.y * GRID_SIZE, GRID_SIZE - 1, GRID_SIZE - 1);
                });
            } else { // Modern or Cyber style (rounded)
                const cornerRadius = (graphicsStyle === 'cyber') ? 3 : 5;
                const inset = 2;
                const headColor = (graphicsStyle === 'cyber') ? '#00e5ff' : '#27ae60';
                const bodyColor = (graphicsStyle === 'cyber') ? '#00b8d4' : '#2ecc71';
                const eyeColor = (graphicsStyle === 'cyber') ? '#ffeb3b' : 'white';

                snake.forEach((part, index) => {
                    const partX = part.x * GRID_SIZE;
                    const partY = part.y * GRID_SIZE;

                    if (index === 0) { // Head
                        ctx.fillStyle = headColor;
                        ctx.beginPath();
                        ctx.roundRect(partX + inset, partY + inset, GRID_SIZE - inset * 2, GRID_SIZE - inset * 2, cornerRadius);
                        ctx.fill();

                        // --- Draw Eyes ---
                        ctx.fillStyle = eyeColor;
                        const eyeSize = 3;
                        let eye1X, eye1Y, eye2X, eye2Y;

                        // Default to looking up if not moving
                        if (dx !== 0) { // Moving Left or Right
                            eye1Y = partY + GRID_SIZE * 0.25;
                            eye2Y = partY + GRID_SIZE * 0.75;
                            eye1X = (dx === 1) ? partX + GRID_SIZE * 0.7 : partX + GRID_SIZE * 0.3;
                            eye2X = eye1X;
                        } else { // Moving Up, Down, or stationary
                            eye1X = partX + GRID_SIZE * 0.25;
                            eye2X = partX + GRID_SIZE * 0.75;
                            eye1Y = (dy === 1) ? partY + GRID_SIZE * 0.7 : partY + GRID_SIZE * 0.3;
                            eye2Y = eye1Y;
                        }

                        ctx.beginPath();
                        ctx.arc(eye1X, eye1Y, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(eye2X, eye2Y, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    } else { // Body
                        ctx.fillStyle = bodyColor;
                        ctx.beginPath();
                        ctx.roundRect(partX + inset, partY + inset, GRID_SIZE - inset * 2, GRID_SIZE - inset * 2, cornerRadius);
                        ctx.fill();
                    }
                });
            }
        }

        /**
         * Draws the food on the canvas.
         */
        function drawFood() {
            if (graphicsStyle === 'classic') {
                ctx.fillStyle = '#e74c3c'; // Classic red
                ctx.fillRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            } else { // Modern or Cyber style (gradient circle)
                const foodX = food.x * GRID_SIZE;
                const foodY = food.y * GRID_SIZE;
                const radius = GRID_SIZE / 2;
                const centerX = foodX + radius;
                const centerY = foodY + radius;

                const gradColor1 = (graphicsStyle === 'cyber') ? '#f06292' : '#ff7675'; // Pink vs Red
                const gradColor2 = (graphicsStyle === 'cyber') ? '#c2185b' : '#d63031'; // Darker Pink vs Darker Red

                const grad = ctx.createRadialGradient(centerX - radius * 0.2, centerY - radius * 0.2, radius * 0.1, centerX, centerY, radius - 2);
                grad.addColorStop(0, gradColor1);
                grad.addColorStop(1, gradColor2);

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 2, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(centerX - radius * 0.3, centerY - radius * 0.4, radius / 4, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        /**
         * Updates the snake's position and checks for collisions or food.
         */
        function moveSnake() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head); // Add new head to the front

            if (checkCollision()) {
                gameOver = true;
                return;
            }

            const hasEatenFood = snake[0].x === food.x && snake[0].y === food.y;
            if (hasEatenFood) {
                score += 10;
                scoreDisplay.textContent = `Score: ${score}`;
                generateFood();
            } else {
                snake.pop(); // Remove tail segment
            }
        }

        /**
         * Checks for wall or self-collision.
         * @returns {boolean} True if a collision occurred.
         */
        function checkCollision() {
            // Self-collision
            for (let i = 4; i < snake.length; i++) {
                if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) return true;
            }
            // Wall collision
            const hitLeftWall = snake[0].x < 0;
            const hitRightWall = snake[0].x >= TILE_COUNT;
            const hitTopWall = snake[0].y < 0;
            const hitBottomWall = snake[0].y >= TILE_COUNT;
            return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall;
        }

        /**
         * Generates a new food item at a random location not on the snake.
         */
        function generateFood() {
            food.x = Math.floor(Math.random() * TILE_COUNT);
            food.y = Math.floor(Math.random() * TILE_COUNT);
            // If food is on the snake, generate a new one
            snake.forEach(part => {
                if (part.x === food.x && part.y === food.y) generateFood();
            });
        }

        /**
         * Handles keyboard input to change the snake's direction.
         */
        function changeDirection(event) {
            // Handle restart on 'Enter' key if game is over
            if (gameOver) {
                if (event.key === 'Enter') {
                    restartGame();
                }
                return;
            }

            if (changingDirection) return;
            changingDirection = true;

            const keyPressed = event.key;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if ((keyPressed === "ArrowLeft" || keyPressed.toLowerCase() === "a") && !goingRight) { dx = -1; dy = 0; }
            if ((keyPressed === "ArrowUp" || keyPressed.toLowerCase() === "w") && !goingDown) { dx = 0; dy = -1; }
            if ((keyPressed === "ArrowRight" || keyPressed.toLowerCase() === "d") && !goingLeft) { dx = 1; dy = 0; }
            if ((keyPressed === "ArrowDown" || keyPressed.toLowerCase() === "s") && !goingUp) { dx = 0; dy = 1; }
        }

        function displayGameOver() {
            // Semi-transparent overlay
            retryButton.classList.remove('hidden');

            let isNewHighScore = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeGameHighScore', highScore);
                highScoreDisplay.textContent = `High Score: ${highScore}`;
                isNewHighScore = true;
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (isNewHighScore) {
                ctx.fillStyle = '#f1c40f'; // Gold color for the reward message
                ctx.font = '24px "Courier New"';
                ctx.fillText('New High Score!', canvas.width / 2, canvas.height / 2 - 80);
            }

            ctx.fillStyle = '#ecf0f1';
            ctx.font = '40px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 40);

            ctx.font = '20px "Courier New"';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 10);

            ctx.font = '16px "Courier New"';
            ctx.fillText('Press ENTER to Play Again', canvas.width / 2, canvas.height / 2 + 50);
        }

        function restartGame() {
            snake = [{ x: 10, y: 10 }];
            dx = 0;
            dy = 0;
            score = 0;
            gameOver = false;
            retryButton.classList.add('hidden');
            scoreDisplay.textContent = `Score: ${score}`;
            main();
        }

        // --- SETTINGS LOGIC ---
        function applySpeed(newSpeed) {
            gameSpeed = parseInt(newSpeed, 10);
            localStorage.setItem('snakeGameSpeed', gameSpeed);

            // Update button styles
            speedControlButtons.forEach(btn => {
                if (parseInt(btn.dataset.speed, 10) === gameSpeed) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function applyGraphicsStyle(newStyle) {
            graphicsStyle = newStyle;
            localStorage.setItem('snakeGameGraphics', graphicsStyle);

            graphicsControlButtons.forEach(btn => {
                if (btn.dataset.style === graphicsStyle) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function applyCustomBackground(url) {
            if (!url) {
                document.body.style.backgroundImage = '';
                localStorage.removeItem('snakeGameCustomBg');
                if (backgroundStyle === 'custom') {
                    applyBackgroundStyle('black'); // Revert to default
                }
                return;
            }
            const img = new Image();
            img.crossOrigin = "Anonymous"; // Handle potential CORS issues
            img.onload = () => {
                document.body.style.backgroundImage = `url(${url})`;
                localStorage.setItem('snakeGameCustomBg', url);
                applyBackgroundStyle('custom'); // Activate the custom style
            };
            img.onerror = () => {
                alert('Could not load image. Please check the URL and try again.');
            };
            img.src = url;
        }

        function generateStars() {
            if (stars.length > 0) return; // Only generate once
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5
                });
            }
        }

        function applyBackgroundStyle(newStyle) {
            backgroundStyle = newStyle;
            localStorage.setItem('snakeGameBackground', backgroundStyle);

            if (backgroundStyle === 'stars') {
                generateStars();
            }

            // If a preset is chosen, clear the custom URL input
            if (newStyle !== 'custom') {
                document.body.style.backgroundImage = '';
                customBgUrlInput.value = '';
                localStorage.removeItem('snakeGameCustomBg');
            }

            backgroundControlButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === backgroundStyle);
            });
        }

        function showProfileModal() {
            const loggedInUser = localStorage.getItem('snakeLoggedInUser');
            if (!loggedInUser) return;

            const userDataString = localStorage.getItem(`snakeUser-${loggedInUser}`);
            if (userDataString) {
                try {
                    const userData = JSON.parse(userDataString);
                    profileUsername.textContent = loggedInUser;
                    profileEmail.textContent = userData.email || 'N/A';
                    profileMobile.textContent = userData.mobile || 'N/A';
                    profilePicUrlInput.value = userData.pfp || '';
                    profileModal.classList.remove('hidden');
                } catch (error) {
                    console.error('Could not load profile data.', error);
                    alert('Could not load profile data.');
                }
            }
        }

        function showAccountSelectionModal(accounts) {
            accountList.innerHTML = ''; // Clear previous list
            accounts.forEach(accUsername => {
                const button = document.createElement('button');
                button.textContent = accUsername;
                button.classList.add('btn-primary');
                button.addEventListener('click', () => {
                    // Log in with the selected username
                    localStorage.setItem('snakeLoggedInUser', accUsername);
                    showLoggedInState(accUsername);
                    // Hide all modals
                    loginModal.classList.add('hidden');
                    accountSelectionModal.classList.add('hidden');
                });
                accountList.appendChild(button);
            });
            loginModal.classList.add('hidden');
            accountSelectionModal.classList.remove('hidden');
        }

        function handleDeleteAccount() {
            const loggedInUser = localStorage.getItem('snakeLoggedInUser');
            if (!loggedInUser) {
                alert('No user is logged in.');
                return;
            }

            const confirmation = window.confirm(
                `Are you sure you want to permanently delete the account "${loggedInUser}"? This action cannot be undone.`
            );

            if (confirmation) {
                // Remove user data from storage
                localStorage.removeItem(`snakeUser-${loggedInUser}`);
                
                // Log the user out (which also removes the session and updates UI)
                handleLogout();
                alert(`Account "${loggedInUser}" has been deleted.`);
            }
        }

        function handleSaveProfilePic() {
            const loggedInUser = localStorage.getItem('snakeLoggedInUser');
            if (!loggedInUser) return;

            const newPfpUrl = profilePicUrlInput.value.trim();
            const userDataString = localStorage.getItem(`snakeUser-${loggedInUser}`);

            if (userDataString) {
                try {
                    const userData = JSON.parse(userDataString);
                    userData.pfp = newPfpUrl;
                    localStorage.setItem(`snakeUser-${loggedInUser}`, JSON.stringify(userData));

                    // Update the visible profile pic immediately
                    if (newPfpUrl) {
                        profilePic.src = newPfpUrl;
                        profilePic.classList.remove('hidden');
                    } else {
                        profilePic.classList.add('hidden');
                    }
                    alert('Profile picture updated!');
                } catch (error) {
                    alert('Failed to save profile picture.');
                    console.error(error);
                }
            }
        }

        // --- AUTH LOGIC (SIMULATED) ---
        function showLoggedInState(username) {
            authContainer.classList.add('hidden');
            userDisplay.classList.remove('hidden');
            welcomeMessage.textContent = `Welcome, ${username}`;

            const userDataString = localStorage.getItem(`snakeUser-${username}`);
            if (userDataString) {
                const userData = JSON.parse(userDataString);
                if (userData.pfp) {
                    profilePic.src = userData.pfp;
                    profilePic.classList.remove('hidden');
                } else {
                    profilePic.classList.add('hidden');
                }
            }
        }

        function generateUniqueUsername() {
            const adjectives = ['Quick', 'Lazy', 'Sleepy', 'Cyber', 'Future', 'Retro', 'Happy', 'Clever', 'Silent', 'Brave'];
            const nouns = ['Fox', 'Dog', 'Cat', 'Lion', 'Panda', 'Snake', 'Player', 'Coder', 'Ghost', 'Ninja', 'Rider'];
            let username;
            let isUnique = false;

            do {
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                const number = Math.floor(Math.random() * 900) + 100; // 100-999
                username = `${adj}${noun}${number}`;

                // Check for uniqueness in our simulated user database
                if (!localStorage.getItem(`snakeUser-${username}`)) {
                    isUnique = true;
                }
            } while (!isUnique);

            return username;
        }

        function showLoggedOutState() {
            authContainer.classList.remove('hidden');
            userDisplay.classList.add('hidden');
        }

        function handleSignup(e) {
            e.preventDefault();
            const username = signupUsernameInput.value;
            const email = document.getElementById('signupEmail').value;
            const mobile = document.getElementById('signupMobile').value;
            const password = document.getElementById('signupPassword').value;
            if (!username || !password || !mobile) {
                alert('Please fill out all required fields (Username, Mobile, Password).');
                return;
            }

            // Check if username is taken
            if (localStorage.getItem(`snakeUser-${username}`)) {
                alert('Username is already taken.');
                return;
            }

            // Check if email or mobile is taken
            for (const key of Object.keys(localStorage)) {
                if (key.startsWith('snakeUser-')) {
                    try {
                        const userData = JSON.parse(localStorage.getItem(key));
                        if (email && userData.email === email) {
                            alert('An account with this email already exists.');
                            return;
                        }
                    } catch (error) {
                        console.error('Error parsing user data from localStorage', error);
                    }
                }
            }

            // In a real app, you'd hash the password.
            const userData = { password, email, mobile, pfp: '' };
            localStorage.setItem(`snakeUser-${username}`, JSON.stringify(userData));

            // Auto-login the user after successful signup
            localStorage.setItem('snakeLoggedInUser', username);
            showLoggedInState(username);

            signupModal.classList.add('hidden');
            signupForm.reset();
        }

        function handleLogin(e) {
            e.preventDefault();
            const identifier = document.getElementById('loginIdentifier').value;
            const password = document.getElementById('loginPassword').value;
            
            let userFound = false;
            let username = '';
            
            const isMobile = /^\d+$/.test(identifier);

            if (identifier.includes('@')) { // Login with email
                for (const key of Object.keys(localStorage)) {
                    if (key.startsWith('snakeUser-')) {
                        try {
                            const userData = JSON.parse(localStorage.getItem(key));
                            if (userData.email === identifier && userData.password === password) {
                                userFound = true;
                                username = key.substring('snakeUser-'.length);
                                break;
                            }
                        } catch (error) {
                            console.error('Error parsing user data from localStorage', error);
                        }
                    }
                }
            } else if (isMobile) { // Login with mobile
                const matchingAccounts = [];
                for (const key of Object.keys(localStorage)) {
                    if (key.startsWith('snakeUser-')) {
                        try {
                            const userData = JSON.parse(localStorage.getItem(key));
                            if (userData.mobile === identifier && userData.password === password) {
                                const foundUsername = key.substring('snakeUser-'.length);
                                matchingAccounts.push(foundUsername);
                            }
                        } catch (error) {
                            console.error('Error parsing user data from localStorage', error);
                        }
                    }
                }

                if (matchingAccounts.length === 1) {
                    userFound = true;
                    username = matchingAccounts[0];
                } else if (matchingAccounts.length > 1) {
                    // This logic correctly handles multiple accounts for one mobile number.
                    showAccountSelectionModal(matchingAccounts);
                    return; // Stop login flow, wait for user selection
                }
            } else { // Login with username
                const userDataString = localStorage.getItem(`snakeUser-${identifier}`);
                if (userDataString) {
                    try {
                        const userData = JSON.parse(userDataString);
                        if (userData.password === password) {
                            userFound = true;
                            username = identifier;
                        }
                    } catch (error) {
                        console.error('Error parsing user data from localStorage', error);
                    }
                }
            }

            if (userFound) {
                localStorage.setItem('snakeLoggedInUser', username);
                showLoggedInState(username);
                loginModal.classList.add('hidden');
                loginForm.reset();
            } else {
                alert('Invalid credentials.');
            }
        }

        function handleLogout() {
            localStorage.removeItem('snakeLoggedInUser');
            showLoggedOutState();
            profileModal.classList.add('hidden'); // Hide profile if open
            profileSettingContainer.classList.add('hidden');
        }

        function checkLoginStatus() {
            const loggedInUser = localStorage.getItem('snakeLoggedInUser');
            if (loggedInUser) {
                showLoggedInState(loggedInUser);
            } else {
                showLoggedOutState();
            }
        }

        // --- EVENT LISTENERS ---
        loginButton.addEventListener('click', () => loginModal.classList.remove('hidden'));
        signupButton.addEventListener('click', () => signupModal.classList.remove('hidden'));
        deleteAccountButton.addEventListener('click', handleDeleteAccount);
        saveProfilePicBtn.addEventListener('click', handleSaveProfilePic);
        logoutButton.addEventListener('click', handleLogout);
        closeModalButtons.forEach(btn => btn.addEventListener('click', () => {
            loginModal.classList.add('hidden');
            signupModal.classList.add('hidden');
            profileModal.classList.add('hidden');
            accountSelectionModal.classList.add('hidden');
        }));
        generateUsernameBtn.addEventListener('click', () => {
            signupUsernameInput.value = generateUniqueUsername();
        });
        noEmailCheckbox.addEventListener('change', () => {
            if (noEmailCheckbox.checked) {
                signupEmailInput.disabled = true;
                signupEmailInput.value = '';
                signupEmailInput.placeholder = 'Email not required';
            } else {
                signupEmailInput.disabled = false;
                signupEmailInput.placeholder = 'Email';
            }
        });
        loginForm.addEventListener('submit', handleLogin);
        signupForm.addEventListener('submit', handleSignup);

        function loadGameData() {
            const savedSpeed = localStorage.getItem('snakeGameSpeed') || 120;
            applySpeed(savedSpeed);

            const savedGraphics = localStorage.getItem('snakeGameGraphics') || 'modern';
            applyGraphicsStyle(savedGraphics);

            const savedBackground = localStorage.getItem('snakeGameBackground') || 'black';
            const savedCustomBg = localStorage.getItem('snakeGameCustomBg');

            if (savedBackground === 'custom' && savedCustomBg) {
                document.body.style.backgroundImage = `url(${savedCustomBg})`;
                customBgUrlInput.value = savedCustomBg;
            }

            applyBackgroundStyle(savedBackground); // This will set the active button

            highScore = parseInt(localStorage.getItem('snakeGameHighScore'), 10) || 0;
            highScoreDisplay.textContent = `High Score: ${highScore}`;

            checkLoginStatus();
        }

        // --- START GAME ---
        document.addEventListener('keydown', changeDirection);
        retryButton.addEventListener('click', restartGame);

        settingsButton.addEventListener('click', () => {
            const loggedInUser = localStorage.getItem('snakeLoggedInUser');
            if (loggedInUser) {
                profileSettingContainer.classList.remove('hidden');
            } else {
                profileSettingContainer.classList.add('hidden');
            }
            settingsModal.classList.remove('hidden');
        });
        closeSettingsButton.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });
        speedControlButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                applySpeed(e.target.dataset.speed);
            });
        });
        profileModalButton.addEventListener('click', () => {
            settingsModal.classList.add('hidden'); // Close settings
            showProfileModal(); // Open profile
        });
        graphicsControlButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                applyGraphicsStyle(e.target.dataset.style);
            });
        });
        backgroundControlButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                applyBackgroundStyle(e.target.dataset.style);
            });
        });
        applyCustomBgBtn.addEventListener('click', () => {
            const url = customBgUrlInput.value.trim();
            applyCustomBackground(url);
        });

        loadGameData();
        generateFood();
        main();
    </script>
</body>
</html>
